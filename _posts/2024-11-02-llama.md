---
layout: post
title: Llama｜Llama 1 2 3 3.1 3.2 系列模型发展
categories: [Llama]
description: Llama 1 2 3 3.1 3.2 系列模型发展
keywords: Llama, Llama1, Llama2, Llama3, Llama3.1, Llama3.2
mermaid: false
sequence: false
flow: false
mathjax: false
mindmap: false
mindmap2: false
topmost: true
---



本文主要讲述 Llama1 、 Llama2 、 Llama3 、 Llama3.1 、 Llama3.2 系列模型的发展。主要包括发布时间、模型大小、模型迭代、模型架构、训练数据、训练方法、训练优化等方面。

## Llama1


### Llama1—发布时间

2023-02

### Llama1—发布链接

[Llama1发布](https://ai.meta.com/blog/large-language-model-llama-meta-ai/)

### 模型大小

7B 13B 33B 65B

### Llama1—模型链接

[Llama1模型](https://github.com/meta-llama/llama/blob/main/MODEL_CARD.md)
[LLaMA: Open and Efficient Foundation Language Models](https://arxiv.org/abs/2302.13971)

### Llama1—模型迭代

- **1**. LLaMA 65B 和 LLaMA 33B 用1.4 万亿个tokens训练
- **2**. LLaMA 7B 用一万亿个tokens训练
- **3**. 模型的词汇表容量被设定为32,000个词条


### Llama1—模型架构


- **1**. 采用了BPE（Byte Pair Encoding）算法进行文本分词，该算法通过sentencepiece库实现；
- **2**. 拆分为独立的数字单元，而对于无法识别的UTF-8字符，则采用字节级别的分解作为备选策略
- **3**. 采用了RMSNorm作为前置的层归一化技术，提升模型训练的稳定性。替代传统的LayerNorm，减少中心化操作，提升计算效率；
- **4**. 提升模型性能方面，选择了SwiGLU作为其激活函数，以增强模型的表达能力。替换FFN中的ReLU激活函数，增强模型性能；
- **5**. 为了更有效地处理长序列数据，引入了RoPE作为其位置编码机制。实现数据并行计算，提升模型推理效率



### Llama1—训练数据

- **1**. Llama1 模型通过利用大量未标注的数据集进行了自监督学习的训练；
- **2**. 训练数据包括：CommonCrawl, C4, Github, Wikipedia, Gutenberg, Books3, ArXiv, Stack Exchange 等

### Llama1—训练方法

Llama1模型是一个基础的自监督学习模型，它没有经过任何形式的特定任务微调。
1. **自监督学习原理** 
   - 通过分析未标记数据，模型预测输入数据的特定部分，自动掌握数据的内在结构。
2. **训练配置与优化** 
   - 采用AdamW优化器，这是Adam优化器的改进版，更优地处理权重衰减，增强训练稳定性。
3. **参数选择与训练策略** 
   - 3.1 参数影响：β1和β2的选择对训练的收敛性和稳定性至关重要；
   - 3.2 学习率调度：余弦学习率调度技术，通过逐步降低学习率，有助于实现更佳的模型收敛。
4. **过拟合与数值稳定性** 
   - 权重衰减与梯度裁剪：实施0.1的权重衰减和1.0的梯度裁剪，是防止过拟合和保证数值稳定性的常规做法。
5. **训练动态与资源优化** 
   - 5.1 预热步骤：作为训练初期的策略，预热步骤有助于稳定训练动态；学习率与批量大小调整：
   - 5.2 根据模型大小调整学习率和批量大小，可以优化资源分配，提升模型效率和性能。


### Llama1—训练优化

Llama1也展示了一系列针对大规模语言模型训练进行的优化措施，主要包括：
1. **内存与计算效率提升** 
   - xformers库应用：利用xformers库中的causal multi-head attention实现，通过避免存储注意力权重和计算被屏蔽的key/query分数，减少内存使用和计算时间。
2. **训练速度与资源消耗** 
   - 2.1 手动实现反向传播：代替自动微分系统，手动实现反向传播函数，提升训练速度。
   - 2.2 检查点技术：通过保存高成本激活，减少资源消耗。
3. **并行性与GPU通信优化** 
   - 模型与序列并行：通过模型和序列的并行化，以及优化GPU间通信，进一步提高训练效率。
4. **大规模模型训练优势** 
   - 参数庞大的模型：这些优化特别适用于训练具有大量参数的模型，如650亿参数的模型，显著缩短训练时间，提高运算效率。
5. **资源管理与效率优化** 
   - 5.1 高性能计算领域：优化技术体现了在高性能计算领域对资源管理和效率优化的深入考量。
   - 5.2 推动模型发展：对于推动大规模语言模型的发展具有关键性的意义。


## Llama2


### Llama2—发布时间

2023-07

### Llama2—发布链接

[Llama2发布](https://ai.meta.com/blog/llama-2/)

### Llama2—模型大小

7B 13B 34B 70B

### Llama2—模型链接

[Llama2模型](https://github.com/meta-llama/llama/blob/main/MODEL_CARD.md) 
[Llama 2: Open Foundation and Fine-Tuned Chat Models](https://arxiv.org/abs/2307.09288)

### Llama2—模型迭代


- **1**. 预训练数据集扩展至2万亿个token，预训练语料扩充，增强模型的泛化能力；
- **2**. 模型的上下文处理能力从2,048个token倍增至4,096个token；
- **3**. 免费商用：降低使用门槛，促进模型在更广泛领域的应用；
- **4**. 推出了专门针对对话应用场景的微调模型系列 Llama-2 Chat；
- **5**. 2023年8月推出了专注于编程代码生成的 Code-Llama。

### Llama2—模型架构

- **1**. Llama2在模型架构和分词器方面与Llama-1保持一致；
- **2**. 采用 SFT + RLHF 等多种技术，对模型迭代；
- **3**. 34B和70B参数版本引入了分组查询注意力机制（Grouped-Query Attention, GQA），提升模型性能，提升模型处理长文本的能力，同时保持高效性

### Llama2—训练数据

- **1**. 为了促进AI的对齐，Llama-2采用了人类反馈强化学习（RLHF），结合了包含1,418,091个Meta样本和七个较小数据集的集合；
- **2**. 在Llama2的预训练阶段，对数据安全性进行了细致的考量；
- **3**. 尽管Llama2的预训练主要集中在英语数据上，但实验结果显示，该模型对其他语言也展现出了一定的掌握能力

### Llama2—训练方法

1. **模型发展与微调** 
   - 1.1 Llama-2模型在Llama-1基础上进一步发展的模型 
   - 1.2 Llama-2-Chat模型基于Llama-2进行微调的版本，与GPT-4不同，保持了固定的4k上下文长度。
2. **微调技术与训练方法** 
   - 2.1 自回归损失函数：在微调Llama-2和Llama-2-Chat时采用，模型在预测下一个token时会考虑所有先前的token。
   - 2.2 用户输入提示处理：在训练中，将用户输入提示的token损失设置为零，使模型专注于生成回复而非这些特定token。
3. **迭代改进与人类反馈** 
   - 3.1 强化学习方法：采用基于人类反馈的RLHF方法，包括拒绝采样和近端策略优化（PPO）。
   - 3.2 奖励模型更新：在RLHF阶段，人类偏好数据并行迭代，以保持奖励模型的持续更新。

### Llama2—训练优化

**Llama-2-Chat训练流程** 
- 预训练阶段：使用公开数据对Llama-2进行预训练。
- 有监督微调：基于预训练模型，通过有监督学习创建Llama-2-Chat的初始版。


## Llama3


### Llama3—发布时间

2024-04

### Llama3—发布链接

[Llama3发布](https://ai.meta.com/blog/meta-llama-3/)

### Llama3—模型大小

8B 70B

### Llama3—模型链接

[Llama3模型](https://github.com/meta-llama/llama3/blob/main/MODEL_CARD.md)
[The Llama 3 Herd of Models](https://arxiv.org/abs/2407.21783)

### Llama3—模型迭代

- **1**. 预训练数据集规模达到了15万亿个token，比LLaMA-2的7倍还多；
- **2**. 词汇表的规模也从32,000扩展至128,000个词条；
- **3**. 模型的上下文处理能力也得到了增强，上下文长度提升至8,000个token。


### Llama3—模型架构

- **1**. 相较于Llama2，Llama3在分词器的选用上做出了调整，从sentencepiece切换到了tiktoken，这一变更与GPT-4的实践相一致
- **2**. Llama 3 还引入了 ChatFormat 类、特殊令牌（包括回合结束标记的令牌）和其他功能，以增强对基于聊天的交互和对话处理的支持
- **3**. 为了增强模型的运算效率，8B和70B参数的版本中都应用了分组查询注意力机制（Grouped-Query Attention, GQA）
- **4**. 大规模预训练数据：增强模型的泛化能力和鲁棒性

### Llama3—训练数据

- **1**. Llama3的训练数据量实现了显著的扩展，从Llama-2的2万亿个token增加到了15万亿个token，增幅达到了8倍；
- **2**. 代码相关数据的量增加了4倍，这一扩充显著增强了模型在编程和逻辑推理方面的能力；
- **3**. Llama3的训练数据集涵盖了大量的编程语言token和超过5%的非英语token；
- **4**. 为了保证训练数据的质量，Meta公司开发了一系列数据清洗流程，包括启发式过滤、NSFW（不适合工作场所）内容过滤、语义重复数据删除技术，以及用于评估数据质量的文本分类器 
- **5**. 前几代Llama在识别高质量数据时表现出乎意料的出色，因此使用Llama2生成了用于训练Llama3文本质量分类器的训练数据；
- **6**.最终预训练数据集中混合来自不同来源的数据。以确保Llama3在包括谜题问答、STEM、编程、历史知识等各种cases中表现良好。


### Llama3—训练方法

1. **Llama-3系列模型** 
   - 1.1 Llama-3：预训练模型，与Llama-2相似，进一步发展而来。
   - 1.2 Llama-3-Instruct：基于Llama-3的微调版本，专为指令遵循设计。
2. **预训练阶段的扩展法则** 
   - Llama-3通过扩展法则有效利用预训练数据，预测模型性能，选择最优数据组合。
3. **新的观察与数据量** 
   - 利用 scaling law 来优化数据组合比例和计算资源
   - hinchilla法则：根据DeepMind提出的法则，8B模型的最优训练数据量约为200B token。
   - 性能提升：实验显示，即使数据量增加两个数量级，模型性能仍在提升，15T token训练后，8B和70B参数模型性能持续对数线性增长。
4. **微调阶段的创新** 
   - 4.1 微调方法：Meta在微调阶段进行了创新，结合了SFT、拒绝采样、PPO和DPO。
   - 4.2 复杂任务优化：综合方法提升了模型在复杂推理和编码任务中的表现，特别是在逻辑推理问题中选择最合适答案的能力。


### Llama3—训练优化


1. **并行策略与训练效率** 
   - 1.1 并行策略：为了训练最大的Llama-3模型，采用了4D并行：TP(tensor parallelism)、PP(pipeline parallelism)、CP(context parallelism)、DP(data parallelism)。
   - 1.2 计算效率：在16K GPU上训练时，实现了每个GPU超过400 TFLOPS的计算利用率。
2. **硬件与软件优化** 
   - 2.1 训练堆栈：Meta开发了新训练堆栈，自动检测和维护错误，提高硬件可靠性。
   - 2.2 存储系统：开发了新的可扩展存储系统，减少检查点和回滚开销，有效训练时间超过95%。
3. **训练效率提升** 
   - 这些改进使Llama-3的训练效率比Llama-2提高了约三倍。


## Llama3.1


### Llama3.1—发布时间

2024-07

### Llama3.1—发布链接

[Llama3.1发布](https://ai.meta.com/blog/meta-llama-3-1/)

### Llama3.1—模型大小

8B 70B 405B


### Llama3.1—模型迭代

- **1**. Llama 3.1 405B，努力提高模型响应用户指令的实用性、质量和详细指令遵循能力，同时确保高水平的安全性。我们最大的挑战是支持更多功能、128K 上下文窗口和增加的模型大小。
- **2**. Llama 3.1 发布，在 15.6T 多语言 tokens 上训练，支持多语言，编程，推理和工具使用。新模型支持 128K tokens 长度的上下文。最大的旗舰模型参数量为 405B，效果达到了闭源模型的 SOTA。


### Llama3.1—模型架构

- **1**. Llama 3.1 的模型和 Llama 3 是一样的，只是做了更精细的训练;
- **2**. 为了支持 405B 规模模型的大规模生产推理，我们将模型从 16 位 (BF16) 量化为 8 位 (FP8) 数字，有效降低了所需的计算要求，并允许模型在单个服务器节点。

### Llama3.1—训练数据

- **1**. 确定旗舰模型的参数规模，确定旗舰模型在下游任务的效果
- **2**. 确定旗舰模型的训练数据混合比例，主要通过**知识分类**和**缩放法则实验**来确定这一数据混合。最终数据混合大致包含：50%的通用知识 tokens，25%的数学和推理 tokens，17%的代码 tokens，以及8%的多语言 tokens。
<!-- https://www.breezedeus.com/article/llama3.1 -->

### Llama3.1—训练方法


- **1**. 预训练 Llama 3 405B 的方案包括三个主要阶段：(1) 初始预训练，(2) 长上下文预训练，(3) 退火。
- **2**. 产生对齐模型的过程包含了 6 轮迭代，每轮都包括有监督微调（SFT）和直接偏好优化（DPO）。数据来自人类标注或者自动生成。在后训练阶段，作者还整合了新的功能，例如工具使用，并观察到在其他领域（如编码和推理）有显著改进。安全缓解措施也在后训练阶段被纳入模型。
- **3**. 后训练包含了一个**奖励模型（Reward Model）**和一个**语言模型**。首先，作者使用人工标注的偏好数据基于预训练模型训练奖励模型。使用奖励模型对人工标注的 prompts 进行拒绝采样。然后，通过 SFT 进一步微调预训练模型，并通过 DPO 进一步对齐模型。
- **4**. 在奖励模型（RM）、有监督微调（SFT）或直接偏好优化（DPO）各个阶段中使用不同的数据或超参数获得了很多模型权重。最终模型的权重值使用了它们的**平均值**。
- **5**. 和 Llama 2 一样，应用上述方法迭代了 6 轮。在每个循环中，作者收集新的偏好标注和SFT数据，并从最新模型中采样合成数据。
- **6**. 在预训练模型的基础上进行几轮对齐来生成最终的聊天模型。每轮都涉及监督微调（SFT）、拒绝采样（RS）和直接偏好优化（DPO）。
- **7**. 使用合成数据生成来生成绝大多数 SFT 示例，并多次迭代以在所有功能上生成越来越高质量的合成数据。
- **8**. 用了多种数据处理技术，以过滤这些合成数据以达到最高质量，这使我们能够跨功能扩展微调数据量。



## Llama3.2


### Llama3.2—发布时间

2024-09

### Llama3.2—发布链接

[Llama3.2发布](https://ai.meta.com/blog/llama-3-2-connect-2024-vision-edge-mobile-devices/)

### Llama3.2—模型大小

1B 3B 11B 90B

- **1**. 适合边缘和移动设备的小型纯文本模型（1B 和 3B）
- **2**. 小型和中型视觉 LLMs（11B 和 90B）


### Llama3.2—模型迭代


- **1**. 1B 和 3B 参数的轻量级纯文本模型，适合边缘设备使用；
- **2**. 11B 和 90B 参数的中小型模型则能够执行包括高分辨率图像多模态处理在内的复杂推理任务
- **3**. Llama 3.2 系列的所有模型均支持 128K 的上下文长度，延续了 Llama 3.1 所具备的扩展令牌容量特性
- **4**. 模型还增强了对八种语言的支持，涵盖了英语、德语、法语、意大利语、葡萄牙语、印地语、西班牙语和泰语。

### Llama3.2—模型架构

1. 自回归语言模型—Llama 3.2 的核心采用了优化的转换器架构，它能够基于之前的上下文预测接下来的内容，从而生成文本。
2. 微调技术—Llama 3.2 的指令调整版本采用了两种关键技术：
   - 2.1 监督式微调 (SFT)—该流程可调整模型，使其遵循特定指令，并生成更相关的响应。
   - 2.2 基于人工反馈的强化学习 (RLHF)—这项先进的技术使模型的输出与人类的偏好保持一致，从而增强实用性和安全性。
3. 多模态功能—对于 11B 和 90B Vision 模型，Llama 3.2 引入了一种新的图像理解方法：
   - 3.1 经过单独训练的图像推理适配器权重与核心 LLM 权重相结合。
   - 3.2 这些适配器通过交叉注意力机制连接到主模型。交叉注意力机制让模型的一部分能够关注另一部分输出中相关的信息，以此实现模型不同部分之间的信息交流。
   - 3.3 当处理输入图像时，该模型将图像推理视为一种“工具使用”行为，这样它就能在处理文本的同时，进行深入的视觉分析。在这里，“工具使用”是一个泛称，指的是模型利用外部资源或功能来提升自己的处理能力，以便更高效地完成任务。
4. 优化推理—所有模型均支持分组查询注意力 (GQA)，这不仅提升了推理速度和效率，尤其对规模更大的 90B 模型带来了显著好处。



### Llama3.2—训练方法

**多模态模型**

- Llama3.2 的 11B 和 90B 模型多模态是基于 Llama3.1-8B、70B 文本模型上，增量增加图像模型。
- 为了添加图像输入支持，训练了一组适配器权重，将预训练的图像编码器集成到预训练的语言模型中。该适配器由一系列交叉注意力层组成，将图像编码器表示输入到语言模型中。在文本-图像对上训练适配器，以将图像表示与语言表示对齐。在适配器训练期间，还更新了图像编码器的参数，但故意不更新语言模型参数。
- 通过这样做，完整地保留了所有纯文本功能，为开发人员提供 Llama 3.1 模型的直接替代品。
  
1. **pretrain 阶段**： 预训练阶段
   - 文本模块由 Llama3.1 模型初始化，并初始化图像编码器，利用大规模噪声（图像、文本、6B 数据对）对数据进行预训练
   - 再用中等规模的高质量的领域、知识增强的（图像、文本、3M 数据对）数据预训练。

2. **posting-train 阶段**： 后训练阶段
   - 通过监督微调、拒绝采样和直接偏好优化进行多轮对齐
   - 使用 Llama 3.1 模型 过滤和增强域内图像上的问题和答案，利用合成数据生成和奖励模型对所有候选答案打分排序，获取高质量的微调数据
   - 还添加了安全数据，以生成具有高安全级别的模型，同时保留该模式的有用性

最终的结果是一组可以同时接受图像和文本提示，并对其组合进行深入理解和推理的模型。这是 Llama 模型向拥有更丰富的代理能力迈出的又一步。


**端侧小模型**

1. **pretrain 阶段**：预训练阶段

   - 1B 和 3B 模型都是基于 8B 模型裁剪后进行模型初始化，并且利用 8B 和 70B 模型进行模型蒸馏，9T 数据预训练。

   - 对于 1B 和 3B 模型，我们采用了 Llama 3.1 8B 中的单次结构化剪枝方法。这涉及系统地删除部分网络并调整权重和梯度的大小，以创建一个更小、更高效的模型，同时保留原始网络的性能。
   - 知识蒸馏使用较大的网络在较小的网络上传授知识，其想法是使用教师较小的模型可以比从头开始获得更好的性能。对于 Llama 3.2 中的 1B 和 3B，我们将 Llama 3.1 8B 和 70B 模型中的 logits 合并到模型开发的预训练阶段，其中这些较大模型的输出（logits）用作 token 级目标。剪枝后使用知识蒸馏来恢复性能。
   - 特别注意，这里蒸馏不是那种通过更大模型进行数据生成的蒸馏，而是在模型训练阶段，利用 Llama 3.1 8B 和 70B 模型输出的 logits 影响模型 loss，也就是传统的蒸馏方法。

2. **posting-train 阶段**：后训练阶段
   
   - 在后期训练中，我们使用与 Llama 3.1 类似的方法，并通过在预训练模型的基础上进行几轮对齐来生成最终的聊天模型。每轮都涉及监督微调（SFT）、拒绝采样（RS）和直接偏好优化（DPO）。

在训练后，我们将上下文长度支持扩展到 128K 个标记，同时保持与预训练模型相同的质量。我们还参与合成数据生成，通过仔细的数据处理和过滤来确保高质量。我们仔细地混合数据，以优化多种功能的高质量，例如摘要、重写、指令遵循、语言推理和工具使用。

### Llama3.2—堆栈分发

**Llama堆栈分发**

Meta为了配合Llama 3.2的推出，还搞了个Llama堆栈。这对开发者来说是个好消息，因为用Llama堆栈，他们就不用担心怎么配置或部署那些复杂的大型模型了。开发者们可以专注于自己的应用开发，剩下的重活累活都交给Llama堆栈来搞定。

**Llama堆栈的亮点包括：** 

1. **标准化API**：开发者可以直接用这些API和Llama模型交互，不用什么都从头做起。
2. **跨平台**：Llama堆栈能在各种平台上运行：  
   - **单节点**：在一台电脑上跑Llama模型。 
   - **本地**：在自己的服务器或私有云上用模型。 
   - **云**：通过AWS或Google Cloud这样的云服务商来部署Llama模型。 
   - **移动和边缘设备**：让模型在不联网的手机上或小设备上也能跑。
  
3. **预构建解决方案**：Llama堆栈提供了现成的解决方案，专门针对一些常见任务，比如文档分析或问题回答，帮开发者省时省力。 
4. **集成安全**：堆栈还自带了安全功能，确保AI在部署的时候能负责任地、符合道德地运行。